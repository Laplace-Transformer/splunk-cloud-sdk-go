// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type filesFlag []string

func (i *filesFlag) String() string {
	return "service file(s) containing struct"
}

func (i *filesFlag) Set(value string) error {
	*i = append(*i, value)
	return nil
}

var options struct {
	service      string
	serviceFiles filesFlag
	structName   string
	iface        string
	icomment     string
	pkgName      string
	outputFile   string
	comment      string
}

// Prints an error message and exits.
func fatal(msg string, args ...interface{}) {
	msg = fmt.Sprintf(msg, args...)
	fmt.Fprintf(os.Stderr, "error: %s\n", msg)
	os.Exit(1)
}

// Set up flags
func init() {
	flag.StringVar(&options.service, "svc", "", "service name")
	flag.Var(&options.serviceFiles, "sf", "service file(s) containing struct")
	flag.StringVar(&options.structName, "s", "Service", "struct to generate interface from")
	flag.StringVar(&options.iface, "i", "Servicer", "name of generated interface")
	flag.StringVar(&options.icomment, "ic", "Servicer represents the interface for implementing all endpoints for this service", "name of generated interface")
	flag.StringVar(&options.pkgName, "p", "", "package name of generated interface")
	flag.StringVar(&options.outputFile, "o", "", "output file name. Print to stdout if not provided")
	flag.Parse()
}

func main() {
	var err error
	outFile := filepath.Join(options.service, "interface.go")
	args := []string{}
	for _, v := range options.serviceFiles {
		file := filepath.Join(options.service, v)
		fmt.Printf("generating from %s\n", file)
		args = append(args, "-f", file)
	}
	args = append(args, "-s", options.structName, "-i", options.iface, "-p", options.pkgName, "--iface-comment", options.icomment, "-c", "Code generated by gen_interface.go. DO NOT EDIT.", "-o", outFile)
	cmd := exec.Command("ifacemaker", args...)
	_, err = cmd.Output()
	if err != nil {
		fatal("%v", err)
	}

	for _, v := range options.serviceFiles {
		if strings.Contains(v, "service_generated.go") {
			file := filepath.Join(options.service, "interface.go")
			fmt.Printf("adding license to %s\n", file)
			err := addLicense(file)

			if err != nil {
				os.Exit(1)
			}
		}
	}
}

func addLicense(filepath string) error {
	licensetxt := []string{
		"/*",
		" * Copyright Â© 2019 Splunk, Inc.",
		" *",
		" * Licensed under the Apache License, Version 2.0 (the \"License\"): you may",
		" * not use this file except in compliance with the License. You may obtain",
		" * a copy of the License at",
		" *",
		" * http://www.apache.org/licenses/LICENSE-2.0",
		" *",
		" * Unless required by applicable law or agreed to in writing, software",
		" * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
		" * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
		" * License for the specific language governing permissions and limitations",
		" * under the License.",
		" */",
		"",
	}

	// read file
	f, err := os.Open(filepath)
	if err != nil {
		fmt.Println(err)
		return err
	}

	var lines []string
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return err
	}

	f.Close()

	// recreate file with license
	file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY, 0644)

	if err != nil {
		fmt.Println("failed creating file: %s", err)
		return err
	}

	datawriter := bufio.NewWriter(file)

	for _, data := range licensetxt {
		_, _ = datawriter.WriteString(data + "\n")
	}

	for _, data := range lines {
		_, _ = datawriter.WriteString(data + "\n")
	}

	datawriter.Flush()
	file.Close()
	return nil
}
